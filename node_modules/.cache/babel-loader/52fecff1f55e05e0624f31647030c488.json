{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport io from 'socket.io-client';\nimport { useAppDispatch, useAppSelector } from '../store/hook';\nimport { clearCurrentRoom, setCurrentRoom, setMatchResult, setMatchState, setMatchStateAfterMove, setRoomList, setRoomListAfterChange } from '../store/game/slice';\nimport { socketHelper } from '../helpers/socketHelper';\nimport { resetTimer, setActiveTimer } from '../store/timer/slice';\nimport { addMessage } from '../store/chat/slice';\nimport { updateAfterMatchFinish } from '../store/auth/slice';\nimport { setLeaderBoards } from '../store/leaderboards/slice';\nimport { setSocketInstance } from '../store/socket/slice';\n/**\r\n * Custom hook use to establish a websocket connection to server and register\r\n * event listener to it\r\n * @param ioType\r\n * @returns\r\n */\n\nexport const useSocket = ioType => {\n  _s();\n\n  const [isLoading, setIsLoading] = useState(true);\n  const [errorMessage, setErrorMessage] = useState();\n  const [socket, setSocket] = useState();\n  const me = useAppSelector(state => state.auth.userInfo);\n  const myRoom = useAppSelector(state => state.game.currentRoom);\n  const dispatch = useAppDispatch();\n\n  const getIOConnection = () => {\n    try {\n      const ioInstance = io(`${process.env.REACT_APP_API || 'http://localhost:3000'}/game`, {\n        withCredentials: true\n      });\n      ioInstance.on('connect_error', () => {\n        console.log('connect error');\n        setErrorMessage('Cant connect to server, trying to establish connection');\n        dispatch(setRoomList([]));\n        dispatch(clearCurrentRoom());\n        dispatch(setMatchState(undefined));\n        dispatch(resetTimer());\n      });\n      ioInstance.on('connect', () => {\n        console.log('connected');\n        setIsLoading(false);\n        setErrorMessage(undefined);\n        dispatch(setSocketInstance({\n          ioType,\n          ioInstance\n        }));\n      });\n      ioInstance.on('disconnect', () => {\n        console.log('disconnected');\n        setErrorMessage('Oops, something wrong');\n        dispatch(setRoomList([]));\n        dispatch(clearCurrentRoom());\n        dispatch(setMatchState(undefined));\n        dispatch(resetTimer());\n      });\n      ioInstance.on('connect_accept', () => {\n        ioInstance.emit('fetch_rooms', fetchedRoomList => {\n          dispatch(setRoomList(fetchedRoomList));\n          ioInstance.emit('retrieve_current_room', ({\n            success,\n            data: room\n          }) => {\n            if (!success) return;\n            const myRole = socketHelper.getMyRole(me, room);\n            if (!myRole) return;\n            dispatch(setCurrentRoom({\n              room,\n              me: myRole\n            }));\n\n            if (room.onGoingMatch) {\n              dispatch(setMatchState(room.onGoingMatch));\n\n              if (room.onGoingMatch.timeout) {\n                dispatch(setActiveTimer(room.onGoingMatch.timeout));\n              }\n            }\n          });\n        });\n      });\n      ioInstance.on('room_change', (room, type) => {\n        dispatch(setRoomListAfterChange({\n          room,\n          type\n        }));\n      });\n      ioInstance.on('room_member_change', room => {\n        const myRole = socketHelper.getMyRole(me, room);\n        if (!myRole) return;\n        dispatch(setCurrentRoom({\n          room,\n          me: myRole\n        }));\n      });\n      ioInstance.on('sync_join', room => {\n        const myRole = socketHelper.getMyRole(me, room);\n        if (!myRole) return;\n        dispatch(setCurrentRoom({\n          room,\n          me: myRole\n        }));\n\n        if (room.onGoingMatch) {\n          dispatch(setMatchState(room.onGoingMatch));\n\n          if (room.onGoingMatch.timeout) {\n            dispatch(setActiveTimer(room.onGoingMatch.timeout));\n          }\n        }\n      });\n      ioInstance.on('match_move', (xIndex, yIndex) => {\n        dispatch(setMatchStateAfterMove({\n          xIndex,\n          yIndex\n        }));\n        dispatch(setActiveTimer({\n          type: 'matchMove',\n          remain: 15\n        }));\n      });\n      ioInstance.on('match_start', matchStartState => {\n        dispatch(setActiveTimer({\n          type: 'matchStart',\n          remain: 3\n        }));\n        dispatch(setMatchState(matchStartState));\n      });\n      ioInstance.on('match_start_cancel', () => {\n        dispatch(setMatchState(undefined));\n        dispatch(resetTimer());\n      });\n      ioInstance.on('match_start_count', matchStartState => {\n        dispatch(setActiveTimer({\n          type: 'matchMove',\n          remain: 15\n        }));\n        dispatch(setMatchState(matchStartState));\n      });\n      ioInstance.on('match_result', matchResult => {\n        dispatch(setMatchResult(matchResult));\n        dispatch(resetTimer());\n        dispatch(setActiveTimer({\n          type: 'matchFinish',\n          remain: 5\n        }));\n      });\n      ioInstance.on('match_finish', room => {\n        dispatch(setMatchState(undefined));\n        dispatch(resetTimer());\n        const myRole = socketHelper.getMyRole(me, room);\n        if (!myRole) return;\n        dispatch(setCurrentRoom({\n          room,\n          me: myRole\n        }));\n      });\n      ioInstance.on('leave_room', () => {\n        dispatch(clearCurrentRoom());\n        dispatch(setMatchState(undefined));\n        dispatch(resetTimer());\n      });\n      ioInstance.on('global_chat', message => {\n        dispatch(addMessage({ ...message\n        }));\n      });\n      ioInstance.on('update_after_match', info => {\n        dispatch(updateAfterMatchFinish(info));\n      });\n      ioInstance.on('leaderBoard', leaderBoard => {\n        dispatch(setLeaderBoards(leaderBoard));\n      });\n      return ioInstance;\n    } catch (error) {\n      console.trace(error); // setHasError(true);\n    } // setIsLoading(false); // fix here\n\n  };\n\n  useEffect(() => {\n    const ioInstance = getIOConnection();\n    setSocket(ioInstance);\n    return () => {\n      ioInstance === null || ioInstance === void 0 ? void 0 : ioInstance.disconnect();\n      dispatch(setRoomList([]));\n      dispatch(clearCurrentRoom());\n      dispatch(setMatchState(undefined));\n      dispatch(resetTimer());\n    };\n  }, []);\n  return {\n    isLoading,\n    errorMessage,\n    socket\n  };\n};\n\n_s(useSocket, \"Zkz4vzygcMKmb3j+1MgiFWpVUxc=\", false, function () {\n  return [useAppSelector, useAppSelector, useAppDispatch];\n});","map":{"version":3,"sources":["E:/Freelancer/Github/caroPlay/client/src/hooks/useSocket.tsx"],"names":["useState","useEffect","io","useAppDispatch","useAppSelector","clearCurrentRoom","setCurrentRoom","setMatchResult","setMatchState","setMatchStateAfterMove","setRoomList","setRoomListAfterChange","socketHelper","resetTimer","setActiveTimer","addMessage","updateAfterMatchFinish","setLeaderBoards","setSocketInstance","useSocket","ioType","isLoading","setIsLoading","errorMessage","setErrorMessage","socket","setSocket","me","state","auth","userInfo","myRoom","game","currentRoom","dispatch","getIOConnection","ioInstance","process","env","REACT_APP_API","withCredentials","on","console","log","undefined","emit","fetchedRoomList","success","data","room","myRole","getMyRole","onGoingMatch","timeout","type","xIndex","yIndex","remain","matchStartState","matchResult","message","info","leaderBoard","error","trace","disconnect"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react';\r\nimport io, { Socket } from 'socket.io-client';\r\nimport { stat } from 'fs';\r\nimport { useAppDispatch, useAppSelector } from '../store/hook';\r\nimport { IOType } from '../store/socket/ioType';\r\nimport {\r\n  OnGoingMatch,\r\n  Room,\r\n} from '../pages/UserHomePage/components/MainBoard/interface/room.interface';\r\nimport {\r\n  clearCurrentRoom,\r\n  MatchState,\r\n  Move,\r\n  setCurrentRoom,\r\n  setMatchResult,\r\n  setMatchState,\r\n  setMatchStateAfterMove,\r\n  setRoomList,\r\n  setRoomListAfterChange,\r\n} from '../store/game/slice';\r\nimport { ILeaderBoard, RetrieveCurrentRoom } from '../interface';\r\nimport { RootState } from '../store';\r\nimport { socketHelper } from '../helpers/socketHelper';\r\nimport { resetTimer, setActiveTimer } from '../store/timer/slice';\r\nimport { Message } from '../store/chat/interface';\r\nimport { addMessage } from '../store/chat/slice';\r\nimport { updateAfterMatchFinish } from '../store/auth/slice';\r\nimport { setLeaderBoards } from '../store/leaderboards/slice';\r\nimport { setSocketInstance } from '../store/socket/slice';\r\n\r\n/**\r\n * Custom hook use to establish a websocket connection to server and register\r\n * event listener to it\r\n * @param ioType\r\n * @returns\r\n */\r\nexport const useSocket = (ioType: IOType) => {\r\n  const [isLoading, setIsLoading] = useState<boolean>(true);\r\n  const [errorMessage, setErrorMessage] = useState<string | undefined>();\r\n  const [socket, setSocket] = useState<Socket | undefined>();\r\n  const me = useAppSelector((state: RootState) => state.auth.userInfo);\r\n  const myRoom = useAppSelector((state: RootState) => state.game.currentRoom);\r\n  const dispatch = useAppDispatch();\r\n\r\n  const getIOConnection = () => {\r\n    try {\r\n      const ioInstance = io(\r\n        `${process.env.REACT_APP_API || 'http://localhost:3000'}/game`,\r\n        { withCredentials: true }\r\n      );\r\n      ioInstance.on('connect_error', () => {\r\n        console.log('connect error');\r\n        setErrorMessage(\r\n          'Cant connect to server, trying to establish connection'\r\n        );\r\n        dispatch(setRoomList([]));\r\n        dispatch(clearCurrentRoom());\r\n        dispatch(setMatchState(undefined));\r\n        dispatch(resetTimer());\r\n      });\r\n      ioInstance.on('connect', () => {\r\n        console.log('connected');\r\n        setIsLoading(false);\r\n        setErrorMessage(undefined);\r\n        dispatch(setSocketInstance({ ioType, ioInstance }));\r\n      });\r\n      ioInstance.on('disconnect', () => {\r\n        console.log('disconnected');\r\n        setErrorMessage('Oops, something wrong');\r\n        dispatch(setRoomList([]));\r\n        dispatch(clearCurrentRoom());\r\n        dispatch(setMatchState(undefined));\r\n        dispatch(resetTimer());\r\n      });\r\n\r\n      ioInstance.on('connect_accept', () => {\r\n        ioInstance.emit('fetch_rooms', (fetchedRoomList: Room[]) => {\r\n          dispatch(setRoomList(fetchedRoomList));\r\n          ioInstance.emit(\r\n            'retrieve_current_room',\r\n            ({ success, data: room }: RetrieveCurrentRoom) => {\r\n              if (!success) return;\r\n              const myRole = socketHelper.getMyRole(me, room);\r\n              if (!myRole) return;\r\n              dispatch(setCurrentRoom({ room, me: myRole }));\r\n              if (room.onGoingMatch) {\r\n                dispatch(setMatchState(room.onGoingMatch));\r\n                if (room.onGoingMatch.timeout) {\r\n                  dispatch(setActiveTimer(room.onGoingMatch.timeout));\r\n                }\r\n              }\r\n            }\r\n          );\r\n        });\r\n      });\r\n\r\n      ioInstance.on('room_change', (room: Room, type: string) => {\r\n        dispatch(setRoomListAfterChange({ room, type }));\r\n      });\r\n\r\n      ioInstance.on('room_member_change', (room: Room) => {\r\n        const myRole = socketHelper.getMyRole(me, room);\r\n        if (!myRole) return;\r\n        dispatch(setCurrentRoom({ room, me: myRole }));\r\n      });\r\n\r\n      ioInstance.on('sync_join', (room: Room) => {\r\n        const myRole = socketHelper.getMyRole(me, room);\r\n        if (!myRole) return;\r\n        dispatch(setCurrentRoom({ room, me: myRole }));\r\n        if (room.onGoingMatch) {\r\n          dispatch(setMatchState(room.onGoingMatch));\r\n          if (room.onGoingMatch.timeout) {\r\n            dispatch(setActiveTimer(room.onGoingMatch.timeout));\r\n          }\r\n        }\r\n      });\r\n\r\n      ioInstance.on('match_move', (xIndex: number, yIndex: number) => {\r\n        dispatch(setMatchStateAfterMove({ xIndex, yIndex }));\r\n        dispatch(setActiveTimer({ type: 'matchMove', remain: 15 }));\r\n      });\r\n\r\n      ioInstance.on('match_start', (matchStartState: OnGoingMatch) => {\r\n        dispatch(setActiveTimer({ type: 'matchStart', remain: 3 }));\r\n        dispatch(setMatchState(matchStartState));\r\n      });\r\n\r\n      ioInstance.on('match_start_cancel', () => {\r\n        dispatch(setMatchState(undefined));\r\n        dispatch(resetTimer());\r\n      });\r\n\r\n      ioInstance.on('match_start_count', (matchStartState: OnGoingMatch) => {\r\n        dispatch(setActiveTimer({ type: 'matchMove', remain: 15 }));\r\n        dispatch(setMatchState(matchStartState));\r\n      });\r\n\r\n      ioInstance.on(\r\n        'match_result',\r\n        (matchResult: { winner: 1 | 2; streak: Move[]; reason?: string }) => {\r\n          dispatch(setMatchResult(matchResult));\r\n          dispatch(resetTimer());\r\n          dispatch(setActiveTimer({ type: 'matchFinish', remain: 5 }));\r\n        }\r\n      );\r\n\r\n      ioInstance.on('match_finish', (room: Room) => {\r\n        dispatch(setMatchState(undefined));\r\n        dispatch(resetTimer());\r\n        const myRole = socketHelper.getMyRole(me, room);\r\n        if (!myRole) return;\r\n        dispatch(setCurrentRoom({ room, me: myRole }));\r\n      });\r\n\r\n      ioInstance.on('leave_room', () => {\r\n        dispatch(clearCurrentRoom());\r\n        dispatch(setMatchState(undefined));\r\n        dispatch(resetTimer());\r\n      });\r\n\r\n      ioInstance.on('global_chat', (message: Message) => {\r\n        dispatch(addMessage({ ...message }));\r\n      });\r\n\r\n      ioInstance.on(\r\n        'update_after_match',\r\n        (info: { win: number; lose: number; username: string }) => {\r\n          dispatch(updateAfterMatchFinish(info));\r\n        }\r\n      );\r\n\r\n      ioInstance.on('leaderBoard', (leaderBoard: ILeaderBoard[]) => {\r\n        dispatch(setLeaderBoards(leaderBoard));\r\n      });\r\n\r\n      return ioInstance;\r\n    } catch (error: any) {\r\n      console.trace(error);\r\n      // setHasError(true);\r\n    }\r\n    // setIsLoading(false); // fix here\r\n  };\r\n\r\n  useEffect(() => {\r\n    const ioInstance = getIOConnection();\r\n    setSocket(ioInstance);\r\n    return () => {\r\n      ioInstance?.disconnect();\r\n      dispatch(setRoomList([]));\r\n      dispatch(clearCurrentRoom());\r\n      dispatch(setMatchState(undefined));\r\n      dispatch(resetTimer());\r\n    };\r\n  }, []);\r\n\r\n  return {\r\n    isLoading,\r\n    errorMessage,\r\n    socket,\r\n  };\r\n};\r\n"]},"metadata":{},"sourceType":"module"}