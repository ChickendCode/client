{"ast":null,"code":"// import createSlice and type definition\nimport { createSlice } from '@reduxjs/toolkit';\n// Define the initial state using that type\nconst initialState = {\n  roomList: []\n};\nexport const gameSlice = createSlice({\n  name: 'game',\n  // `createSlice` will infer the state type from the `initialState` argument\n  initialState,\n  reducers: {\n    setRoomList: (state, action) => ({ ...state,\n      roomList: action.payload\n    }),\n    setRoomListAfterChange: (state, action) => {\n      const {\n        room,\n        type\n      } = action.payload;\n\n      switch (type) {\n        case 'new_room':\n          state.roomList.push(room);\n          break;\n\n        case 'remove_room':\n          const index1 = state.roomList.findIndex(roomData => roomData.name === room.name);\n\n          if (index1 >= 0) {\n            state.roomList.splice(index1, 1);\n          }\n\n          break;\n\n        case 'change':\n          const index2 = state.roomList.findIndex(roomData => roomData.name === room.name);\n\n          if (index2 >= 0) {\n            state.roomList[index2] = room;\n          }\n\n          break;\n\n        default: // console.log(room);\n        // console.log(type);\n\n      }\n    },\n    setCurrentRoom: (state, action) => ({ ...state,\n      currentRoom: action.payload\n    }),\n    clearCurrentRoom: state => ({ ...state,\n      currentRoom: undefined\n    }),\n    setMatchState: (state, action) => {\n      state.currentMatch = action.payload;\n    },\n    setMatchStateAfterMove: (state, action) => {\n      const {\n        xIndex,\n        yIndex\n      } = action.payload;\n      const currentMatchState = JSON.parse(JSON.stringify(state.currentMatch));\n      if (!currentMatchState) return;\n      currentMatchState.matchMoves[xIndex][yIndex] = currentMatchState.nextTurn;\n      currentMatchState.nextTurn = currentMatchState.nextTurn === 1 ? 2 : 1;\n      currentMatchState.lastMove = {\n        xIndex,\n        yIndex\n      };\n      state.currentMatch = currentMatchState;\n    },\n    setMatchResult: (state, action) => {\n      const currentMatchState = JSON.parse(JSON.stringify(state.currentMatch));\n      if (!currentMatchState) return;\n      currentMatchState.result = action.payload;\n      state.currentMatch = currentMatchState;\n    } // Use the PayloadAction type to declare the contents of `action.payload`\n\n  }\n});\nexport const {\n  setRoomList,\n  setRoomListAfterChange,\n  setCurrentRoom,\n  setMatchState,\n  setMatchStateAfterMove,\n  setMatchResult,\n  clearCurrentRoom\n} = gameSlice.actions; // Other code such as selectors can use the imported `RootState` type\n// export const selectCount = (state: RootState) => state.counter.value;\n\nexport default gameSlice.reducer;","map":{"version":3,"sources":["E:/Freelancer/Github/caroPlay/client/src/store/game/slice.ts"],"names":["createSlice","initialState","roomList","gameSlice","name","reducers","setRoomList","state","action","payload","setRoomListAfterChange","room","type","push","index1","findIndex","roomData","splice","index2","setCurrentRoom","currentRoom","clearCurrentRoom","undefined","setMatchState","currentMatch","setMatchStateAfterMove","xIndex","yIndex","currentMatchState","JSON","parse","stringify","matchMoves","nextTurn","lastMove","setMatchResult","result","actions","reducer"],"mappings":"AAAA;AACA,SAASA,WAAT,QAAoD,kBAApD;AAsBA;AACA,MAAMC,YAAuB,GAAG;AAC9BC,EAAAA,QAAQ,EAAE;AADoB,CAAhC;AAoBA,OAAO,MAAMC,SAAS,GAAGH,WAAW,CAAC;AACnCI,EAAAA,IAAI,EAAE,MAD6B;AAEnC;AACAH,EAAAA,YAHmC;AAInCI,EAAAA,QAAQ,EAAE;AACRC,IAAAA,WAAW,EAAE,CAACC,KAAD,EAAQC,MAAR,MAA2C,EACtD,GAAGD,KADmD;AAEtDL,MAAAA,QAAQ,EAAEM,MAAM,CAACC;AAFqC,KAA3C,CADL;AAKRC,IAAAA,sBAAsB,EAAE,CAACH,KAAD,EAAQC,MAAR,KAA8C;AACpE,YAAM;AAAEG,QAAAA,IAAF;AAAQC,QAAAA;AAAR,UAAiBJ,MAAM,CAACC,OAA9B;;AACA,cAAQG,IAAR;AACE,aAAK,UAAL;AACEL,UAAAA,KAAK,CAACL,QAAN,CAAeW,IAAf,CAAoBF,IAApB;AACA;;AACF,aAAK,aAAL;AACE,gBAAMG,MAAM,GAAGP,KAAK,CAACL,QAAN,CAAea,SAAf,CACZC,QAAD,IAAcA,QAAQ,CAACZ,IAAT,KAAkBO,IAAI,CAACP,IADxB,CAAf;;AAGA,cAAIU,MAAM,IAAI,CAAd,EAAiB;AACfP,YAAAA,KAAK,CAACL,QAAN,CAAee,MAAf,CAAsBH,MAAtB,EAA8B,CAA9B;AACD;;AACD;;AACF,aAAK,QAAL;AACE,gBAAMI,MAAM,GAAGX,KAAK,CAACL,QAAN,CAAea,SAAf,CACZC,QAAD,IAAcA,QAAQ,CAACZ,IAAT,KAAkBO,IAAI,CAACP,IADxB,CAAf;;AAGA,cAAIc,MAAM,IAAI,CAAd,EAAiB;AACfX,YAAAA,KAAK,CAACL,QAAN,CAAegB,MAAf,IAAyBP,IAAzB;AACD;;AACD;;AACF,gBApBF,CAqBE;AACA;;AAtBF;AAwBD,KA/BO;AAgCRQ,IAAAA,cAAc,EAAE,CAACZ,KAAD,EAAQC,MAAR,MAEb,EACC,GAAGD,KADJ;AAECa,MAAAA,WAAW,EAAEZ,MAAM,CAACC;AAFrB,KAFa,CAhCR;AAsCRY,IAAAA,gBAAgB,EAAGd,KAAD,KAEf,EACC,GAAGA,KADJ;AAECa,MAAAA,WAAW,EAAEE;AAFd,KAFe,CAtCV;AA4CRC,IAAAA,aAAa,EAAE,CAAChB,KAAD,EAAQC,MAAR,KAA4D;AACzED,MAAAA,KAAK,CAACiB,YAAN,GAAqBhB,MAAM,CAACC,OAA5B;AACD,KA9CO;AA+CRgB,IAAAA,sBAAsB,EAAE,CAAClB,KAAD,EAAQC,MAAR,KAAwC;AAC9D,YAAM;AAAEkB,QAAAA,MAAF;AAAUC,QAAAA;AAAV,UAAqBnB,MAAM,CAACC,OAAlC;AACA,YAAMmB,iBAA2C,GAAGC,IAAI,CAACC,KAAL,CAClDD,IAAI,CAACE,SAAL,CAAexB,KAAK,CAACiB,YAArB,CADkD,CAApD;AAGA,UAAI,CAACI,iBAAL,EAAwB;AACxBA,MAAAA,iBAAiB,CAACI,UAAlB,CAA6BN,MAA7B,EAAqCC,MAArC,IAA+CC,iBAAiB,CAACK,QAAjE;AACAL,MAAAA,iBAAiB,CAACK,QAAlB,GAA6BL,iBAAiB,CAACK,QAAlB,KAA+B,CAA/B,GAAmC,CAAnC,GAAuC,CAApE;AACAL,MAAAA,iBAAiB,CAACM,QAAlB,GAA6B;AAAER,QAAAA,MAAF;AAAUC,QAAAA;AAAV,OAA7B;AACApB,MAAAA,KAAK,CAACiB,YAAN,GAAqBI,iBAArB;AACD,KAzDO;AA0DRO,IAAAA,cAAc,EAAE,CACd5B,KADc,EAEdC,MAFc,KAGX;AACH,YAAMoB,iBAA2C,GAAGC,IAAI,CAACC,KAAL,CAClDD,IAAI,CAACE,SAAL,CAAexB,KAAK,CAACiB,YAArB,CADkD,CAApD;AAGA,UAAI,CAACI,iBAAL,EAAwB;AACxBA,MAAAA,iBAAiB,CAACQ,MAAlB,GAA2B5B,MAAM,CAACC,OAAlC;AACAF,MAAAA,KAAK,CAACiB,YAAN,GAAqBI,iBAArB;AACD,KApEO,CAqER;;AArEQ;AAJyB,CAAD,CAA7B;AA6EP,OAAO,MAAM;AACXtB,EAAAA,WADW;AAEXI,EAAAA,sBAFW;AAGXS,EAAAA,cAHW;AAIXI,EAAAA,aAJW;AAKXE,EAAAA,sBALW;AAMXU,EAAAA,cANW;AAOXd,EAAAA;AAPW,IAQTlB,SAAS,CAACkC,OARP,C,CAUP;AACA;;AAEA,eAAelC,SAAS,CAACmC,OAAzB","sourcesContent":["// import createSlice and type definition\r\nimport { createSlice, PayloadAction, current } from '@reduxjs/toolkit';\r\nimport {\r\n  OnGoingMatch,\r\n  Player,\r\n  Room,\r\n  Viewer,\r\n} from '../../pages/UserHomePage/components/MainBoard/interface/room.interface';\r\nimport type { RootState } from '../index';\r\n// import { UserInfo } from './interface';\r\n\r\nexport interface ICurrentRoom {\r\n  room: Room;\r\n  me: Viewer | Player;\r\n}\r\n\r\n// Define a type for the slice state\r\ninterface GameState {\r\n  roomList: Room[];\r\n  currentRoom?: ICurrentRoom;\r\n  currentMatch?: OnGoingMatch;\r\n}\r\n\r\n// Define the initial state using that type\r\nconst initialState: GameState = {\r\n  roomList: [],\r\n};\r\n\r\ninterface RoomChange {\r\n  room: Room;\r\n  // type: 'new_room' | 'remove_room' | 'room_change';\r\n  type: string;\r\n}\r\n\r\nexport interface Move {\r\n  xIndex: number;\r\n  yIndex: number;\r\n}\r\n\r\nexport interface MatchState {\r\n  matchMoves: (1 | 2 | null)[][];\r\n  nextTurn: 1 | 2;\r\n}\r\n\r\nexport const gameSlice = createSlice({\r\n  name: 'game',\r\n  // `createSlice` will infer the state type from the `initialState` argument\r\n  initialState,\r\n  reducers: {\r\n    setRoomList: (state, action: PayloadAction<Room[]>) => ({\r\n      ...state,\r\n      roomList: action.payload,\r\n    }),\r\n    setRoomListAfterChange: (state, action: PayloadAction<RoomChange>) => {\r\n      const { room, type } = action.payload;\r\n      switch (type) {\r\n        case 'new_room':\r\n          state.roomList.push(room);\r\n          break;\r\n        case 'remove_room':\r\n          const index1 = state.roomList.findIndex(\r\n            (roomData) => roomData.name === room.name\r\n          );\r\n          if (index1 >= 0) {\r\n            state.roomList.splice(index1, 1);\r\n          }\r\n          break;\r\n        case 'change':\r\n          const index2 = state.roomList.findIndex(\r\n            (roomData) => roomData.name === room.name\r\n          );\r\n          if (index2 >= 0) {\r\n            state.roomList[index2] = room;\r\n          }\r\n          break;\r\n        default:\r\n        // console.log(room);\r\n        // console.log(type);\r\n      }\r\n    },\r\n    setCurrentRoom: (state, action: PayloadAction<ICurrentRoom>) =>\r\n      // const\r\n      ({\r\n        ...state,\r\n        currentRoom: action.payload,\r\n      }),\r\n    clearCurrentRoom: (state) =>\r\n      // const\r\n      ({\r\n        ...state,\r\n        currentRoom: undefined,\r\n      }),\r\n    setMatchState: (state, action: PayloadAction<OnGoingMatch | undefined>) => {\r\n      state.currentMatch = action.payload;\r\n    },\r\n    setMatchStateAfterMove: (state, action: PayloadAction<Move>) => {\r\n      const { xIndex, yIndex } = action.payload;\r\n      const currentMatchState: OnGoingMatch | undefined = JSON.parse(\r\n        JSON.stringify(state.currentMatch)\r\n      );\r\n      if (!currentMatchState) return;\r\n      currentMatchState.matchMoves[xIndex][yIndex] = currentMatchState.nextTurn;\r\n      currentMatchState.nextTurn = currentMatchState.nextTurn === 1 ? 2 : 1;\r\n      currentMatchState.lastMove = { xIndex, yIndex };\r\n      state.currentMatch = currentMatchState;\r\n    },\r\n    setMatchResult: (\r\n      state,\r\n      action: PayloadAction<{ winner: 1 | 2; streak: Move[]; reason?: string }>\r\n    ) => {\r\n      const currentMatchState: OnGoingMatch | undefined = JSON.parse(\r\n        JSON.stringify(state.currentMatch)\r\n      );\r\n      if (!currentMatchState) return;\r\n      currentMatchState.result = action.payload;\r\n      state.currentMatch = currentMatchState;\r\n    },\r\n    // Use the PayloadAction type to declare the contents of `action.payload`\r\n  },\r\n});\r\n\r\nexport const {\r\n  setRoomList,\r\n  setRoomListAfterChange,\r\n  setCurrentRoom,\r\n  setMatchState,\r\n  setMatchStateAfterMove,\r\n  setMatchResult,\r\n  clearCurrentRoom,\r\n} = gameSlice.actions;\r\n\r\n// Other code such as selectors can use the imported `RootState` type\r\n// export const selectCount = (state: RootState) => state.counter.value;\r\n\r\nexport default gameSlice.reducer;\r\n"]},"metadata":{},"sourceType":"module"}